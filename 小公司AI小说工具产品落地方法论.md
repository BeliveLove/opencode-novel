# 小公司 AI 小说工具产品落地方法论（OpenCode TUI 版）

## 核心定位

本方法论聚焦**用户交互层、产品功能层、能力封装层**三层架构，面向「资源有限、需要快速验证市场」的小团队，采用**痛点导向、轻量化落地、快速试错、数据联动**的策略，让 AI 小说工具用最低成本跑通 MVP 并进入迭代。

与通用方法论不同的是：本项目的交互层选择 **OpenCode 的命令式/TUI**（`/novel-*`），不走 Web/小程序路线。

## 一、核心产品原则

1. **痛点优先，拒绝功能堆砌**：只解决高频痛点（没灵感、卡文、设定混乱、文风差、一致性崩、伏笔没收），其余需求延后。
2. **轻量化落地，重投入不自研**：不自研大模型；依赖 OpenCode 已配置的模型与供应商，把精力放在场景提示词、流程与数据结构上。
3. **三层联动，数据全程互通**：灵感/设定/大纲/章节/巡检报告在一个工程内复用，避免重复输入与信息丢失。
4. **快速试错，小步快跑迭代**：先做可用 MVP（能写完一章并导出），再按反馈补齐缺口。
5. **创作者主导，AI 协同辅助**：默认不覆盖正文，AI 产出以“可审阅的草稿/建议/候选”为主，作者负责最终决策。

## 二、能力封装层（TUI 版）：提示词模板 + Context Pack + 确定性工具

### 核心方法

在 OpenCode 中把能力拆成两类：
- **确定性工具（Tools）**：扫描、索引、巡检、导出、受控落盘 —— 不依赖模型，结果稳定可复现。
- **专家能力（Skills/Agents）**：人物画像/续写/润色/摘要/结构诊断 —— 通过提示词模板驱动模型。

二者通过 `novel_context_pack` 串起来：在预算内打包“事实源 + 派生摘要 + 目标章节/线程”给模型，减少胡编与跑偏。

### 建议的 8 个原子能力（面向作者感知）

1) 灵感/主线诊断（oracle）  
2) 世界观/名词/规则整理（worldbible）  
3) 大纲生成（outline）  
4) 章节计划（chapter plan）  
5) 草稿/续写（draft/continuation）  
6) 润色/重写（polish/rewrite）  
7) 一致性/伏笔对账（continuity + foreshadowing）  
8) 导出发布（export）  

### 验收标准（能力层）

- 工具执行稳定、可复现；报告文件结构固定，可被人和模型共同阅读。
- 模型相关能力至少做到：输入明确、输出结构化、可落盘点位清楚（而不是“泛泛建议”）。

## 三、产品功能层：用命令组合出最小闭环（MVP）

### 核心方法

把“模块”落到 TUI 的**命令组**：每组只保留 1–3 个高频命令，保证用户在 3 步内完成关键动作。

### MVP 命令闭环（建议写死在产品文档/引导里）

1) 初始化：`/novel-init "书名"`  
2) 索引：`/novel-index`  
3) 写章：`/novel-chapter-plan ch0001` → `/novel-chapter-draft ch0001`  
4) 巡检：`/novel-continuity-check` + `/novel-foreshadowing-audit`  
5) 导出：`/novel-export docx`（或 epub/html）  

### 数据联动（文件即数据库）

- 事实源：`manuscript/`（章节/角色/势力/线程/地点/世界观）
- 派生物：`.opencode/novel/`（索引/报告/图/上下文包/cache）
- 关键原则：任何“自动化”都应尽量写入派生物；需要影响事实源时必须走受控落盘/显式确认。

## 四、用户交互层（OpenCode TUI）：流程化命令 + 低学习成本

### 核心方法

用**命令提示 + 固定输出协议 + 安全落盘**代替 GUI：
- 命令名清晰可记（`/novel-init`、`/novel-index`、`/novel-export`）
- 每条命令控制在 1–3 个关键输入
- 所有工具输出统一包含：Summary / Result(JSON) / Diagnostics（便于排错与自动化）

### 关键交互规则（必须遵守）

1) **默认不覆盖正文**：草稿/润色/重写输出到新文件；覆盖必须显式确认。  
2) **即时反馈**：每次生成/巡检必须产出可读报告或可复制结果，不让用户“猜发生了什么”。  
3) **可回退**：提供快照/导出/报告留痕，让作者敢用、敢试。  

## 五、落地与迭代方法

### （一）落地三步走（TUI 版）

1. **第 1 阶段（MVP）**：init/import/index/export 能跑通；写完一章并导出。  
2. **第 2 阶段（质量）**：一致性/伏笔/风格巡检可用，能定位问题并给出最小改动建议。  
3. **第 3 阶段（效率）**：实体候选抽取→受控落盘、上下文包策略、模板沉淀与体验打磨。  

### （二）迭代方法

1. **需求收集**：只收集“共性高频痛点”，优先修复上手链路与失效点（安装、目录约定、命令跑不通）。  
2. **需求排序**：按「影响范围 × 实现成本」排，优先做高影响/低成本（提示词模板、索引稳定性、错误提示）。  
3. **迭代节奏**：两周一版，只解决 1–2 个核心问题，避免堆功能。  

## 六、核心竞争力打造（TUI 版）

小公司避开“全功能大而全”，做透三件事：
1) **流程聚焦**：把“写完一章”变成可重复的命令链路。  
2) **一致性聚焦**：用工具把时间线/人物状态/伏笔承诺变成可检查、可回收的资产。  
3) **安全聚焦**：默认不覆盖、受控落盘、报告留痕，让作者信任工具。  

## 七、必避核心坑点（TUI 版）

1. **命令大而全**：不要一开始就上几十条命令；先保证 5 条命令闭环能跑通。  
2. **把 GUI 当成必需品**：TUI 也能做到低学习成本，关键在引导、默认值与输出协议。  
3. **过度追求“完美生成”**：以“可用初稿 + 可审稿/可回滚”为目标，靠迭代提升。  
4. **目录约定不一致**：命令/技能的目录与覆盖规则必须写死且与实现一致，否则扩展必崩。  
5. **重开发轻反馈**：MVP 出来就拉小规模作者公测，优先修链路而不是加功能。  

> （注：本文为本项目的 TUI 落地版方法论，强调可执行与可验收。）
